! --------------------------------------------------------------------
! Copyright (C) 1991 - 2020 - EDF R&D - www.code-aster.org
! This file is part of code_aster.
!
! code_aster is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! code_aster is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
! --------------------------------------------------------------------
!
subroutine prelogsb9(l_resi   , ndim     , lgpg, vim, &
                     epsg_prev, epsg_curr, fm  ,fp  , &
                     gn       , lamb     , logl,&
                     epsl_prev, epsl_incr,&
                     t_prev   , iret)
!
implicit none
!
#include "asterf_types.h"
#include "asterfort/deflogsb9.h"
#include "asterfort/r8inir.h"
#include "blas/dcopy.h"
#include "asterfort/lcdetf.h"
#include "asterc/r8prem.h"
!
aster_logical, intent(in) :: l_resi
integer, intent(in) :: ndim, lgpg
real(kind=8), intent(in) :: vim(lgpg)
real(kind=8), intent(in) :: epsg_curr(6), epsg_prev(6),fm(3,3),fp(3,3)
real(kind=8), intent(out) :: epsl_prev(6), epsl_incr(6)
real(kind=8), intent(out) :: gn(3, 3), lamb(3), logl(3)
real(kind=8), intent(out) :: t_prev(6)
integer, intent(out) :: iret
!
! --------------------------------------------------------------------------------------------------
!
! Solid-shell element
!
! Pre-treatment for GDEF_LOG
!
! --------------------------------------------------------------------------------------------------
!
! In  l_resi           : flag if compute internal force
! In  ndim             : dimension of problem
! In  lgpg             : length of internal state variable vector
! In  vim              : internal state variables at beginning of time step
! In  epsg_prev        : Green-Lagrange strains at beginning of time step
! In  epsg_curr        : Green-Lagrange strains at end of time step
! Out gn               : eigen vectors for F tensor
! Out lamb             : eigen values for F tensor
! Out logl             : log(lamb)
! Out epsl_prev        : logarithmic strains at beginning of time step
! Out epsl_incr        : increment of logarithmic strains
! Out t_prev           : "logarithmic" stresses at beginning of time step
! Out iret             : return code for error
!                         0=OK, 1=vp(Ft.F) trop petites (compression infinie)
!
! --------------------------------------------------------------------------------------------------
!
    integer :: i, ivtn
    real(kind=8) :: epsl_curr(6),detf
!
! --------------------------------------------------------------------------------------------------
!
    epsl_incr = 0.d0
    t_prev    = 0.d0
    iret=0
!
!
!   DETERMINANT DE LA MATRICE Fm
    call lcdetf(3, fm, detf)
!
!    PERTINENCE DES GRANDEURS
    if (detf .le. r8prem()) then
        iret = 1
        goto 999
    endif
! - Compute increment of logarithmic strains
!
    !WRITE(6,*) 'Defo-L1: ', epsg_prev
    call deflogsb9(epsg_prev, epsl_prev, gn, lamb, logl, iret)
!
    if (iret .ne. 0) goto 999
!
! - Compute current logarithmic strains
!
    if (l_resi) then
    !   DETERMINANT DE LA MATRICE Fp
        call lcdetf(3, fp, detf)
!
!       PERTINENCE DES GRANDEURS
        if (detf .le. r8prem()) then
            iret = 1
            goto 999
        endif

        call deflogsb9(epsg_curr, epsl_curr, gn, lamb, logl, iret)
        !print*,'def_curr',iret
        !if (iret .ne. 0) goto 999
        if (iret .ne. 0) goto 999
!
        do i = 1, 6
            epsl_incr(i) = epsl_curr(i) - epsl_prev(i)
        end do
        !WRITE(6,*) 'Defo-L3: ', epsg_curr, epsl_curr, gn, lamb, logl
    endif
!
! - Get "logarithmic" stresses from internal state variables at previous time step
!
    ivtn = lgpg-6+1
    call dcopy(2*ndim, vim(ivtn), 1, t_prev, 1)
!
999 continue
!
end subroutine
