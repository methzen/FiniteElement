! --------------------------------------------------------------------
! Copyright (C) 1991 - 2020 - EDF R&D - www.code-aster.org
! This file is part of code_aster.
!
! code_aster is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! code_aster is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
! --------------------------------------------------------------------
!
subroutine nmgrtgstab(option   , l_large,&
                      nb_node  , nb_dof ,&
                      geom_init, dispp   ,dispm,&
                      Ueff   ,&
                      matuu    , vectu)
!
implicit none
!
#include "asterf_types.h"
#include "asterfort/assert.h"
#include "asterfort/shbBDevMatrix.h"
#include "asterfort/rigistab.h"
#include "asterfort/fintstab.h"
#include "asterfort/rigigeostab.h"
#include "asterfort/mattbsb.h"
#include "asterfort/shbBMatrix.h"
!
character(len=16), intent(in) :: option
aster_logical, intent(in) :: l_large
integer, intent(in) :: nb_node, nb_dof
real(kind=8), intent(in) :: geom_init(3*nb_node), dispp(nb_dof),dispm(nb_dof)
real(kind=8), intent(in)  :: Ueff
real(kind=8), intent(out) :: vectu(*), matuu(*)
!
! --------------------------------------------------------------------------------------------------
!
! Solid-shell element
!
! Compute stabilization for elastic matrix and linear internal force
!
! --------------------------------------------------------------------------------------------------
!
! In  option           : option to compute
! In  l_large          : flag for large strains
! In  nb_node          : number of nodes of element without pinch node(s)
! In  nb_dof           : number of dof
! In  geom_init        : initial coordinates of element
! In  disp             : displacements of element
! In  det              : determinant of initial jacobian matrix
! In  Ueff             : effective shear modulus
! Out vectu            : linear internal force vector
! Out matuu            : elastic matrix
!
! --------------------------------------------------------------------------------------------------
!
    integer :: i, j, k
    aster_logical :: resi, rigi,sb7,sb9
    real(kind=8) :: Kgstab(24,24), Kmstab(3*nb_node,3*nb_node), Fstab(3*nb_node),eye(2,2)
    real(kind=8) :: BXIdev(6,24), BETAdev(6,24), BETAZETAdev(6,24), BXIZETAdev(6,24)
    real(kind=8) :: BXI(6,3*nb_node), BETA(6,3*nb_node)
    real(kind=8) :: BXIZETA(6,3*nb_node), BETAZETA(6,3*nb_node),det,B(6,25)
    real(kind=8) :: disp(nb_dof)
!
! --------------------------------------------------------------------------------------------------
!
    sb7=(nb_node .eq. 6) .and. (nb_dof .eq. 19)
    sb9=(nb_node .eq. 8) .and. (nb_dof .eq. 25)
    ASSERT(sb7.or. sb9)
!    ASSERT(nb_node .eq. 6 .and. nb_dof .eq. 19)
    eye=0.d0
    eye(1,1)=1.d0
    eye(2,2)=1.d0
    resi = option(1:9) .eq. 'FULL_MECA' .or. option(1:9) .eq. 'RAPH_MECA'
    rigi = option(1:10) .eq. 'RIGI_MECA_' .or. option(1: 9) .eq. 'FULL_MECA'
!
! - Compute the deformation gradient B in cartesian base - Deviatoric part
!
!----------SB9---------------------------------------------------------------
        if (resi) then
            call shbBMatrix(nb_node, nb_dof     ,l_large,&
                            0.d0   , geom_init  ,dispp,det,B,&
                            BXI, BXIZETA,BETA,BETAZETA )
        else 
            call shbBMatrix(nb_node, nb_dof,l_large,&
                            0.d0   , geom_init  ,dispm,det, B,&
                            BXI, BXIZETA,BETA,BETAZETA)
        endif

        call shbBDevMatrix(nb_node    , &
                           BXI        , BETA      ,&
                           BXIZETA    , BETAZETA  ,&
                           BXIdev     , BETAdev   ,&
                           BETAZETAdev, BXIZETAdev)
        if (rigi) then 
            call rigistab(nb_node   , Ueff       ,&
                          BXIdev    , BETAdev    ,&
                          BXIZETAdev, BETAZETAdev,&
                          Kmstab)
            k = 0
            do i = 1, 3*nb_node
                do j = 1, i
                    k = k + 1
                    matuu(k) = matuu(k) + abs(det)*Kmstab(i,j)
                enddo
            enddo

            if (l_large) then
                if (option(1:4) .eq. 'RIGI') then
                    disp=dispm
                else
                    disp=dispp
                endif
            
                call rigigeostab(nb_node    , nb_dof,&
                                 geom_init  , disp      , Ueff,&
                                 BXIdev     , BETAdev   ,&
                                 BETAZETAdev, BXIZETAdev,&
                                 Kgstab)
                k = 0
                do i = 1, 3*nb_node
                    do j = 1, i
                        k = k + 1
                        matuu(k) = matuu(k) + abs(det)*Kgstab(i,j)
                    enddo
                enddo

            endif
            !WRITE(6,*) 'Stab. matrice (geom): ',matuu(1:25*25)
        endif 

        if (resi) then 
                call fintstab(l_large    , &
                              nb_node    , nb_dof    ,&
                              geom_init  , dispp     , Ueff,&
                              BXIdev     , BETAdev   ,&
                              BETAZETAdev, BXIZETAdev,&
                              Fstab)
                do i = 1, 3*nb_node
                    vectu(i) = vectu(i)+abs(det)*Fstab(i)
                enddo
        endif 
!
!----------------------------------------------------------------------------
!
end subroutine
