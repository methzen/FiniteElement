! --------------------------------------------------------------------
! Copyright (C) 1991 - 2019 - EDF R&D - www.code-aster.org
! This file is part of code_aster.
!
! code_aster is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! code_aster is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
! --------------------------------------------------------------------
!
subroutine shbBDevMatrix(nb_node    ,&
                         BXI        , BETA      ,&
                         BXIZETA    , BETAZETA  ,BXIETA,&
                         BXIdev     , BETAdev   ,&
                         BETAZETAdev, BXIZETAdev,BXIETAdev)
!
implicit none
!
#include "asterf_types.h"
#include "asterfort/assert.h"
!
integer, intent(in) :: nb_node
real(kind=8), intent(in) :: BXI(6,3*nb_node), BETA(6,3*nb_node)
real(kind=8), intent(in) :: BXIZETA(6,3*nb_node), BETAZETA(6,3*nb_node),BXIETA(6,3*nb_node)
real(kind=8), intent(out) :: BXIdev(6,3*nb_node), BETAdev(6,3*nb_node)
real(kind=8), intent(out) :: BETAZETAdev(6,3*nb_node), BXIZETAdev(6,3*nb_node),BXIETAdev(6,3*nb_node)
!
! --------------------------------------------------------------------------------------------------
!
! Solid-shell element
!
! Compute the deformation gradient B in cartesian base - Deviatoric part
!
! --------------------------------------------------------------------------------------------------
!
! In  nb_node          : number of nodes of element without pinch node(s)
! In  BXI              : xi part of gradient matrix
! In  BETA             : eta part of gradient matrix
! In  BXIZETA          : xi x zeta part of gradient matrix
! In  BETAZETA         : eta x zeta part of gradient matrix
! Out BXIdev           : xi part of gradient matrix (deviatoric part)
! Out BETAdev          : eta part of gradient matrix (deviatoric part)
! Out BETAZETAdev      : eta x zeta part of gradient matrix (deviatoric part)
! Out BXIZETAdev       : xi x zeta part of gradient matrix (deviatoric part)
!
! --------------------------------------------------------------------------------------------------
!
    real(kind=8) :: BXIv(6,24), BETAv(6,24), BETAZETAv(6,24), BXIZETAv(6,24)
    real(kind=8) :: Balpha(3,3)
    real(kind=8) :: alpha1, alpha2, alpha3
    integer :: i, j, col1, col2
!
! --------------------------------------------------------------------------------------------------
!
    ASSERT(nb_node .eq. 8)
    !
    !***************************************************************************
    ! D'apres Hughes c'est termes sont deja deviatoric dans leur forme initiale.
    !***************************************************************************
    !
    !
    BXIv = 0.d0
    do i = 1, nb_node
        alpha1 = 0.d0
        alpha2 = 0.d0
        alpha3 = 0.d0
        col1   = 3*(i-1)+1
        col2   = 3*(i-1)+3
        Balpha = BXI(1:3,col1:col2)
        do j = 1, 3
            alpha1 = alpha1 + Balpha(j,1)
            alpha2 = alpha2 + Balpha(j,2)
            alpha3 = alpha3 + Balpha(j,3)
        enddo
        BXIv(1,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BXIv(2,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BXIv(3,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
    enddo
    !BXIdev = BXI-BXIv
    BXIdev = BXI

    BETAv = 0.d0
    do i = 1, nb_node
        alpha1 = 0.d0
        alpha2 = 0.d0
        alpha3 = 0.d0
        col1   = 3*(i-1)+1
        col2   = 3*(i-1)+3
        Balpha = BETA(1:3,col1:col2)
        do j = 1, 3
            alpha1 = alpha1 + Balpha(j,1)
            alpha2 = alpha2 + Balpha(j,2)
            alpha3 = alpha3 + Balpha(j,3)
        enddo
        BETAv(1,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BETAv(2,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BETAv(3,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
    enddo
    !BETAdev = BETA-BETAv
    BETAdev = BETA
!
    BETAZETAv = 0.d0
    do i = 1, nb_node
        alpha1 = 0.d0
        alpha2 = 0.d0
        alpha3 = 0.d0
        col1   = 3*(i-1)+1
        col2   = 3*(i-1)+3
        Balpha = BETAZETA(1:3,col1:col2)
        do j = 1, 3
            alpha1 = alpha1 + Balpha(j,1)
            alpha2 = alpha2 + Balpha(j,2)
            alpha3 = alpha3 + Balpha(j,3)
        enddo
        BETAZETAv(1,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BETAZETAv(2,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BETAZETAv(3,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
    enddo
    !BETAZETAdev = BETAZETA-BETAZETAv
    BETAZETAdev = BETAZETA
!
    BXIZETAv = 0.d0
    do i = 1, nb_node
        alpha1 = 0.d0
        alpha2 = 0.d0
        alpha3 = 0.d0
        col1   = 3*(i-1)+1
        col2   = 3*(i-1)+3
        Balpha = BXIZETA(1:3,col1:col2)
        do j = 1, 3
            alpha1 = alpha1 + Balpha(j,1)
            alpha2 = alpha2 + Balpha(j,2)
            alpha3 = alpha3 + Balpha(j,3)
        enddo
        BXIZETAv(1,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BXIZETAv(2,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
        BXIZETAv(3,col1:col2)=(/alpha1, alpha2, alpha3/)/3.d0
    enddo
    !BXIZETAdev = BXIZETA-BXIZETAv
    BXIZETAdev = BXIZETA


    BXIETAdev = BXIETA
!
end subroutine
