! --------------------------------------------------------------------
! Copyright (C) 1991 - 2020 - EDF R&D - www.code-aster.org
! This file is part of code_aster.
!
! code_aster is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! code_aster is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
! --------------------------------------------------------------------
!
subroutine nmgrtgsb9(option   , l_large,&
                     nb_node  , nb_dof ,&
                     geom     , zeta   ,&
                     jacobian , dsidep ,&
                     dispp    , dispm  ,&
                     sigp     , sigm   ,&
                     matuu    , vectu )
!
implicit none
!
#include "asterf_types.h"
#include "asterfort/assert.h"
#include "asterfort/mattbsb.h"
#include "asterfort/rigigeo.h"
#include "asterfort/shbBMatrix.h"
#include "asterfort/assemBsb7.h"
!
character(len=16), intent(in) :: option
aster_logical, intent(in) :: l_large
integer, intent(in) :: nb_node, nb_dof
real(kind=8), intent(in) :: geom(*), zeta, dispp(nb_dof), dispm(nb_dof) 
real(kind=8), intent(in) :: dsidep(6, 6), jacobian, sigm(6), sigp(6)
real(kind=8), intent(out) :: matuu(*), vectu(*)
!
! --------------------------------------------------------------------------------------------------
!
! Solid-shell element
!
! Compute elastic matrix and linear internal force at current Gauss point
!
! --------------------------------------------------------------------------------------------------
!
! In  option           : option to compute
! In  l_large          : flag for large strains
! In  nb_node          : number of nodes of element without pinch node(s)
! In  nb_dof           : number of dof
! In  geom_init        : initial coordinates of element
! In  zeta             : out-of-plane parametric component
! In  jacobian         : product of determinant and gauss weight
! In  dsidep           : jacobian matrix of behaviour (dSigm/dEpsi)
! In  sigm             : Cauchy stresses
! In  B                : gradient B matrix
! Out vectu            : linear internal force vector
! Out matuu            : elastic matrix
!
! --------------------------------------------------------------------------------------------------
!
    aster_logical :: l_resi, l_rigi,sb9,sb7
    real(kind=8)  :: btdb(nb_dof, nb_dof), Kg(nb_dof, nb_dof),sigg(6)
    integer :: i, j, k, isig
    real(kind=8) :: B(6, nb_dof),BXI(6, 3*nb_node), BXIZETA(6, 3*nb_node) 
    real(kind=8) :: BETA(6, 3*nb_node), BETAZETA(6, 3*nb_node),det ,Bstab(2,18)
!
! --------------------------------------------------------------------------------------------------
!
    sb9=nb_node .eq. 8 .and. nb_dof .eq. 25
    sb7=nb_node .eq. 6 .and. nb_dof .eq. 19
    ASSERT(sb9 .or. sb7)
    l_resi = option(1:9) .eq. 'FULL_MECA' .or. option(1:9) .eq. 'RAPH_MECA'
    l_rigi = option(1:10) .eq. 'RIGI_MECA_' .or. option(1: 9) .eq. 'FULL_MECA'

    if (sb9) then
        if (l_resi) then
            call shbBMatrix(nb_node, nb_dof,l_large,&
                            zeta   , geom  ,dispp, det,B,&
                            BXI, BXIZETA,BETA,BETAZETA )
        else 
            call shbBMatrix(nb_node, nb_dof,l_large,&
                            zeta   , geom  ,dispm, det, B,&
                            BXI, BXIZETA,BETA,BETAZETA)
        endif
    else 
        call assemBsb7(nb_node,geom,zeta,B,Bstab,det)
    endif
!
! - Compute tangent matrix
!
    if (l_rigi) then
        if (option(1:4) .eq. 'RIGI') then
            sigg(1)=sigm(1)
            sigg(2)=sigm(2)
            sigg(3)=sigm(3)
            sigg(4)=sigm(4)
            sigg(5)=sigm(5)
            sigg(6)=sigm(6)
        else
            sigg(1)=sigp(1)
            sigg(2)=sigp(2)
            sigg(3)=sigp(3)
            sigg(4)=sigp(4)
            sigg(5)=sigp(5)
            sigg(6)=sigp(6)
        endif
! ----- Compute material rigidity
        call mattbsb(dsidep, 6, nb_dof, B, btdb)
!
! ----- Compute geometric rigidity
        if (l_large) then
                call rigigeo(nb_node, sigg, geom, zeta, Kg)
                !WRITE(6,*) 'Matrice géométrique: ',Kg
                do i = 1, 3*nb_node
                    do j = 1, 3*nb_node
                        btdb(i,j) = btdb(i,j) + Kg(i,j)
                    enddo
                enddo
        endif
        k = 0
        do i = 1, nb_dof
            do j = 1, i
                k = k + 1
                matuu(k) = matuu(k) + jacobian*btdb(i,j)
            enddo
        enddo
        !WRITE(6,*) 'Matrice: ',matuu(1:nb_dof*nb_dof)
    endif
!
! - Compute internal force
!
    if (l_resi) then
        do i = 1, nb_dof
            do isig = 1, 6
                vectu(i) = vectu(i) + B(isig,i)*sigp(isig)*jacobian
            enddo
        enddo
        !WRITE(6,*) 'Vecteur: ',vectu(1:nb_dof)
    endif
!
end subroutine
