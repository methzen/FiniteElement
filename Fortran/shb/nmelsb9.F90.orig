! --------------------------------------------------------------------
! Copyright (C) 1991 - 2020 - EDF R&D - www.code-aster.org
! This file is part of code_aster.
!
! code_aster is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! code_aster is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
! --------------------------------------------------------------------
! aslint: disable=W1504
!
subroutine nmelsb9(BEHinteg ,&
                   typmod   , option  , fami  , poum,&
                   npg      , nb_node , nb_dof, lgpg,&
                   jv_poids , jv_coopg,&
                   geom_init, imate   ,&
                   angl_naut, compor  , carcri,&
                   disp     , sig     , vi    ,&
                   matuu    , vectu   ,&
                   codret)
!
use Behaviour_type
!
implicit none
!
#include "asterf_types.h"
#include "jeveux.h"
#include "asterc/r8nnem.h"
#include "asterfort/Behaviour_type.h"
#include "asterfort/assert.h"
#include "asterfort/nmcpel.h"
#include "asterfort/sb9coefstab.h"
#include "asterfort/matriceBcart.h"
#include "asterfort/nmgrtgstab.h"
#include "asterfort/nmgeosb9.h"
#include "asterfort/nmgrtgsb9.h"
#include "asterfort/shbBMatrix.h"
#include "asterfort/matriceBsb7.h"
#include "asterfort/assemBsb7.h"
#include "asterfort/mattbsb.h"
!
type(Behaviour_Integ), intent(in) :: BEHinteg
character(len=8), intent(in)  :: typmod(*)
character(len=16), intent(in) :: option
character(len=*), intent(in)  :: fami, poum
integer, intent(in) :: npg, nb_node, nb_dof, lgpg
integer, intent(in) :: jv_poids, jv_coopg
real(kind=8), intent(in)  :: geom_init(*)
integer, intent(in) :: imate
real(kind=8), intent(in)  :: angl_naut(3)
character(len=16), intent(in) :: compor(*)
real(kind=8), intent(in)  :: carcri(*)
real(kind=8), intent(in)  :: disp(nb_dof)
real(kind=8), intent(out) :: sig(6, npg), vi(lgpg, npg)
real(kind=8), intent(out) :: matuu(*), vectu(*)
integer, intent(out) :: codret
!
! --------------------------------------------------------------------------------------------------
!
! Solid-shell element
!
! Compute non-linear options for hyperelasticity
!
! --------------------------------------------------------------------------------------------------
!
! In  BEHinteg         : parameters for integration of behaviour
! In  typmod           : type of modelization
! In  option           : option to compute
! In  fami             : Gauss family for integration point rule
! In  poum             : time for parameters evaluation 
!                        '-' at beginning of time step
!                        '+' at end of time step
! In  npg              : number of Gauss points
! In  nb_node          : number of nodes of element without pinch node(s)
! In  nb_dof           : number of dof
! In  lgpg             : length of internal state variable vector
! In  jv_poids         : JEVEUX adress to weight of Gauss points
! In  jv_coopg         : JEVEUX adress to coordinates of Gauss points
! In  geom_init        : initial coordinates of element
! In  imate            : coded material address
! In  angl_naut        : nautical angles for anistropic material
! In  compor           : behaviour
! In  carcri           : parameters for behaviour
! In  disp             : displacements of element
! Out sig              : stresses
! Out vi               : internal state variables
! Out vectu            : internal force vector
! Out matuu            : tangent matrix
! Out codret           : return code for error
!
! --------------------------------------------------------------------------------------------------
!
    integer :: kpg, i_tens,i,j,k
    real(kind=8) :: dsidep(6, 6), epsi(6), sigma(6)
    real(kind=8) :: poids, zeta, det
    aster_logical :: l_large,sb9,sb7
    real(kind=8), parameter :: rac2 = sqrt(2.d0)
    real(kind=8) :: B0(6,24), B9(6), B(6, nb_dof)
    real(kind=8) :: BXI(6,24), BETA(6,24), BZETA(6,24),BXIETA(6,24)
    real(kind=8) :: BXIZETA(6,24), BETAZETA(6,24), BZETAZETA(6,24)
    real(kind=8) :: u1eff, ueff
    real(kind=8) :: disp_prev(nb_dof)
    real(kind=8) :: Bstab(2,18)
    real(kind=8) :: jacgau,tBsDBs(18,18),eye(2,2)
!
! --------------------------------------------------------------------------------------------------
!
    sb9=(nb_node .eq. 8).and.(nb_dof .eq. 25)
    sb7=(nb_node .eq. 6).and.(nb_dof .eq. 19)
    ASSERT(sb7 .or. sb9)
    u1eff     = 0.d0
    ueff      = 0.d0
    disp_prev = 0.d0
    B0=0.d0
    BXI=0.d0
    BETA=0.d0
    BZETA=0.d0
    BXIZETa=0.d0
    BETAZETA=0.d0
    BZETAZETA=0.d0
    Bstab=0.d0
    eye=0.d0
    eye(1,1)=1.d0
    eye(2,2)=1.d0
!
! - For non-linear kinematic option
!
    l_large   = compor(DEFO) .eq. 'GROT_GDEP'
!
! - Compute the deformation gradient in cartesian base
!
    if (sb9) then 
!
!-------------------------------SB9-------------------------------
        if (l_large) then 
                call matriceBcart(nb_node  , geom_init,&
                      nb_dof   , disp     ,&
                      B0       , BZETA    , BZETAZETA,&
                      BXI      , BETA     ,&
                      BXIZETA  , BETAZETA ,BXIETA,&
                      det)
        else
                call matriceBcart(nb_node  , geom_init,&
                          nb_dof   , disp_prev,&
                          B0       , BZETA    , BZETAZETA,&
                          BXI      , BETA     ,&
                          BXIZETA  , BETAZETA ,BXIETA,&
                          det)
        endif
!
! - Loop on Gauss points
!
        do kpg = 1, npg
            !WRITE(6,*) 'Point de Gauss: ',kpg
            zeta  = zr(jv_coopg-1+3*kpg)            
            poids = zr(jv_poids+kpg-1)
            !print*,'GAUSSETPOIDS',zeta,poids
! ----- Compute B matrix at current Gauss point
!
            call shbBMatrix(nb_node, nb_dof   ,&
                            zeta   , geom_init,&
                            B0     , BZETA    , BZETAZETA,&
                            B      , B9)
! ----- Compute Green-Lagrange or small strains sb9
            call nmgeosb9(l_large  ,&
                          nb_node  , nb_dof,&
                          geom_init, zeta  , disp     ,&
                          B0       , BZETA , BZETAZETA,&
                          epsi)
! ------Add EAS effect
            epsi    = epsi + B9*disp(25)
            epsi(4) = epsi(4)/rac2
            epsi(5) = epsi(5)/rac2
            epsi(6) = epsi(6)/rac2
!
! ----- Integrate behaviour law
            call nmcpel(BEHInteg,&
                    fami    , kpg      , 1    , poum      , 3     ,&
                    typmod  , angl_naut, imate, compor    , carcri,&
                    option  , epsi     , sigma, vi(1, kpg), dsidep,&
                    codret)
        
            sigma(4)        = sigma(4)/rac2
            sigma(5)        = sigma(5)/rac2
            sigma(6)        = sigma(6)/rac2
            epsi(4)         = epsi(4)*rac2
            epsi(5)         = epsi(5)*rac2
            epsi(6)         = epsi(6)*rac2
            dsidep(4:6,4:6) = dsidep(4:6,4:6)/2.d0
            dsidep(4:6,1:3) = dsidep(4:6,1:3)/rac2
            dsidep(1:3,4:6) = dsidep(1:3,4:6)/rac2
!
! ----- Compute effective shear modulus for stabilization
            call sb9coefstab(option, epsi,epsi,sigma,&
                             sigma,dsidep,poids, Ueff)            
            jacgau=det*poids
! ----- Compute elastic matrix and linear internal force at current Gauss point
            call nmgrtgsb9(option   , l_large,&
                            nb_node  , nb_dof ,&
                            geom_init, zeta   ,&
                            jacgau   , dsidep ,&
                            sigma    , sigma,B,&
                            matuu    , vectu)
!
! ----- Compute stresses
            if (option(1:9) .eq. 'FULL_MECA' .or. option(1:9) .eq. 'RAPH_MECA') then
                do i_tens = 1, 6
                    sig(i_tens, kpg) = sigma(i_tens)
                enddo
            endif
        enddo
!
! - Compute stabilization for elastic matrix and linear internal force
!
    call nmgrtgstab(option   , l_large,&
                    nb_node  , nb_dof ,&
                    geom_init, disp   ,disp,&
                    det      , Ueff   ,&
                    BXI      , BETA   ,&
                    BETAZETA , BXIZETA,BXIETA,&
                    matuu    , vectu)
    else 
!-----------------------------SB7------------------------------------
! - Loop on Gauss points
!
        do kpg = 1, npg
!
            zeta  = zr(jv_coopg-1+3*kpg)
            poids = zr(jv_poids+kpg-1)
!
! ----- Compute B matrix at current Gauss point
!
            call assemBsb7(nb_node,geom_init,zeta,B,Bstab,det)
!
!-------Compute small strains sb7
!
            epsi=matmul(B,disp)
!
            epsi(4) = epsi(4)/rac2
            epsi(5) = epsi(5)/rac2
            epsi(6) = epsi(6)/rac2
!
        !WRITE(6,*) 'DÃ©formation de Green-Lagrange: ',epsi
! ----- Integrate behaviour law
            call nmcpel(BEHInteg,&
                        fami    , kpg      , 1    , poum      , 3     ,&
                        typmod  , angl_naut, imate, compor    , carcri,&
                        option  , epsi     , sigma, vi(1, kpg), dsidep,&
                        codret)
        
            sigma(4)        = sigma(4)/rac2
            sigma(5)        = sigma(5)/rac2
            sigma(6)        = sigma(6)/rac2
            dsidep(4:6,4:6) = dsidep(4:6,4:6)/2.d0
            dsidep(4:6,1:3) = dsidep(4:6,1:3)/rac2
            dsidep(1:3,4:6) = dsidep(1:3,4:6)/rac2
!
!------- Stabilization parameter
!
            Ueff=dsidep(3,3)/1200.d0
            jacgau=det*poids
!
! ----- Compute elastic matrix and linear internal force at current Gauss point
!
            call nmgrtgsb9(option   , l_large,&
                           nb_node  , nb_dof ,&
                           geom_init, zeta   ,&
                           jacgau   , dsidep ,&
                           sigma    , sigma,B,&
                           matuu    , vectu)
!
!-----------Stabilization of twist mode 
            call mattbsb(eye*Ueff, 2, 3*nb_node, Bstab, tBsDBs)
            k = 0
            do i = 1, 3*nb_node
                do j = 1, i
                    k = k + 1
                    matuu(k) = matuu(k) + jacgau*tBsDBs(i,j)
                enddo
            enddo
            do i = 1, 3*nb_node
                do j = 1, 3*nb_node
                    vectu(i) = vectu(i) + tBsDBs(i,j)*disp(j)*jacgau
                enddo
            enddo
! ----- Compute stresses
            if (option(1:9) .eq. 'FULL_MECA' .or. option(1:9) .eq. 'RAPH_MECA') then
                do i_tens = 1, 6
                    sig(i_tens, kpg) = sigma(i_tens)
                enddo
            endif
        enddo

    endif 
!
end subroutine
